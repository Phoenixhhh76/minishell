
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hho-troc <hho-troc@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 14:44:38 by hho-troc          #+#    #+#             */
/*   Updated: 2025/05/20 14:48:28 by hho-troc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int	handle_var_assignment(char **env, char *joined, char ***mini_env, int index)
{
	if (!joined)
		return (-1);
	if (index >= 0)
	{
		free(env[index]);
		env[index] = ft_strdup(joined);
		if (!env[index])
			return (-1);
	}
	else
	{
		if (add_var_to_env(env, joined, mini_env) < 0)
			return (-1);
	}
	return (0);
}

void	add_to_exp_list(char ***exp_list, const char *key)
{
	int		len;
	char	**new_list;
	int		i;

	len = 0;
	i = 0;
	while (*exp_list && (*exp_list)[len])
		len++;
	new_list = ft_calloc(len + 2, sizeof(char *));
	while (i < len)
	{
		new_list[i] = ft_strdup((*exp_list)[i]);
		i++;
	}
	new_list[i] = ft_strdup(key);
	new_list[i + 1] = NULL;
	free_double_tab(*exp_list);
	*exp_list = new_list;
}

void	remove_from_exp_list(char ***exp_list, const char *key)
{
	int		i;
	int		j;
	int		len;
	char	**new_list;

	i = 0;
	j = 0;
	len = 0;
	while (*exp_list && (*exp_list)[len])
		len++;
	new_list = ft_calloc(len, sizeof(char *));
	if (!new_list)
		return ;
	while ((*exp_list)[i])
	{
		if (ft_strcmp((*exp_list)[i], key) != 0)
			new_list[j++] = ft_strdup((*exp_list)[i]);
		i++;
	}
	new_list[j] = NULL;
	free_double_tab(*exp_list);
	*exp_list = new_list;
}

int	ft_export(t_cmd *cmd, char ***mini_env, t_mini *mini)
{
	int		i;
	int		status;

	i = 1;
	status = 0;
	if (!cmd || !cmd->cmd_args || !cmd->cmd_args[1])
	{
		print_export_env(*mini_env, mini->exp_list);
		return (0);
	}
	while (cmd->cmd_args[i])
	{
		if (handle_single_export(cmd->cmd_args[i], mini_env, mini) != 0)
		status = 1;
		i++;
	}
	mini->last_exit = status;
	return (status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hho-troc <hho-troc@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 12:33:03 by hho-troc          #+#    #+#             */
/*   Updated: 2025/05/20 12:32:13 by hho-troc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

static void	swap(char **a, char **b)
{
	char	*tmp;

	tmp = *a;
	*a = *b;
	*b = tmp;
}

static void	sort_env(char **env)
{
	int	i;
	int	j;

	i = 0;
	while (env[i])
	{
		j = i + 1;
		while (env[j])
		{
			if (ft_strcmp(env[i], env[j]) > 0)
				swap(&env[i], &env[j]);
			j++;
		}
		i++;
	}
}

void	print_export_env(char **env, char **exp_list)
{
	int		i;
	char	**sorted;

	i = 0;
	if (!env && !exp_list)
		return ;
	sorted = clone_and_sort_env(env);
	if (sorted)
	{
		while (sorted[i])
		{
			print_sorted_env_line(sorted[i]);
			i++;
		}
		free_double_tab(sorted);
	}
	i = 0;
	while (exp_list && exp_list[i])
	{
		write(1, "declare -x ", 11);
		write(1, exp_list[i], ft_strlen(exp_list[i]));
		write(1, "\n", 1);
		i++;
	}
}

char	**clone_and_sort_env(char **env)
{
	int		i;
	int		count;
	char	**sorted;

	i = 0;
	count = 0;
	while (env[count])
		count++;
	sorted = ft_calloc(count + 1, sizeof(char *));
	if (!sorted)
		return (NULL);
	while (i < count)
	{
		sorted[i] = ft_strdup(env[i]);
		i++;
	}
	sorted[i] = NULL;
	sort_env(sorted);
	return (sorted);
}

void	print_sorted_env_line(const char *entry)
{
	const char	*equal;
	size_t		name_len;
	size_t		val_len;

	equal = ft_strchr(entry, '=');
	if (equal && equal != entry)
	{
		name_len = equal - entry;
		val_len = ft_strlen(equal + 1);
		write(1, "declare -x ", 11);
		write(1, entry, name_len);
		write(1, "=\"", 2);
		write(1, equal + 1, val_len);
		write(1, "\"\n", 2);
	}
	else
	{
		write(1, "declare -x ", 11);
		write(1, entry, ft_strlen(entry));
		write(1, "\n", 1);
	}
}


#include "../../includes/minishell.h"

int	handle_single_export(char *arg, char ***mini_env, t_mini *mini)
{
	char	**env;

	env = *mini_env;
	if (!arg || !arg[0] || arg[0] == '=' || !is_valid_var_name(arg))
		return (export_err_msg(arg, 1));
	if (!ft_strchr(arg, '='))
	{
		if (!is_valid_var_name(arg))
			return (export_err_msg(arg, 1));
		should_store_unassigned_var(arg, env, mini);
		return (0);
	}
	return (handle_var_with_equal(arg, env, mini_env, mini));
}

void	should_store_unassigned_var(char *arg, char **env, t_mini *mini)
{
	if (does_var_exist(env, arg) < 0 && !in_exp_list(mini->exp_list, arg))
		add_to_exp_list(&mini->exp_list, arg);
}

int	handle_var_with_equal(char *arg,
					char **env, char ***mini_env, t_mini *mini)
{
	char	**var;
	char	*joined;
	int		env_index;

	var = split_export_arg(arg);
	if (!var || !var[0] || var[0][0] == '\0')
		return (free_double_tab(var), -1);
	if (in_exp_list(mini->exp_list, var[0]))
		remove_from_exp_list(&mini->exp_list, var[0]);
	joined = make_joined_assignment(var);
	if (!joined)
		return (free_double_tab(var), -1);
	env_index = does_var_exist(env, var[0]);
	if (handle_var_assignment(env, joined, mini_env, env_index) < 0)
		return (free_double_tab(var), free(joined), -1);
	free_double_tab(var);
	free(joined);
	return (0);
}

#include "../../includes/minishell.h"

char	*strip_quotes_only(const char *val)
{
	size_t	len;

	if (!val)
		return (NULL);
	len = ft_strlen(val);
	if (len >= 2 && ((val[0] == '"' && val[len - 1] == '"') || \
					(val[0] == '\'' && val[len - 1] == '\'')))
		return (ft_substr(val, 1, len - 2));
	else
		return (ft_strdup(val));
}

char	**split_export_arg(const char *arg)
{
	char	*equal;
	size_t	name_len;
	char	*name;
	char	**out;

	if (!arg)
		return (NULL);
	equal = ft_strchr(arg, '=');
	if (!equal || equal == arg)
		return (NULL);
	name_len = equal - arg;
	name = ft_strndup(arg, name_len);
	out = ft_calloc(3, sizeof(char *));
	if (!out)
		return (free(name), NULL);
	out[0] = name;
	out[1] = ft_strdup(equal + 1);
	if (!out[0] || !out[1])
	{
		free_double_tab(out);
		return (NULL);
	}
	return (out);
}

char	*make_joined_assignment(char **var)
{
	char	*cleaned_val;
	char	*joined;

	cleaned_val = strip_quotes_only(var[1]);
	if (!cleaned_val)
		return (NULL);
	joined = ft_strjoin(var[0], "=");
	if (!joined)
		return (free(cleaned_val), NULL);
	joined = ft_strjoin_f(joined, cleaned_val);
	free(cleaned_val);
	return (joined);
}

#include "../../includes/minishell.h"

int	count_token_args(t_token *tok, t_mini *mini)
{
	char	*expanded;
	int		count;

	count = 0;
	expanded = expand_if_needed(tok, mini);
	if (!expanded)
		return (0);
	if (tok->quote_type == Q_S || tok->quote_type == Q_D)
		count = 1;
	else if (expanded[0] != '\0')
		count = count_expanded_split(expanded);
	else
		count = 0;
	free(expanded);
	return (count);
}

int	count_expanded_split(char *expanded)
{
	char	**split;
	int		count;
	int		i;

	count = 0;
	i = 0;
	split = ft_split(expanded, ' ');
	while (split && split[i])
	{
		count++;
		i++;
	}
	free_double_tab(split);
	return (count);
}

int	count_export_args(t_token *start, t_token *end, t_mini *mini)
{
	int			count;
	char		*expanded;
	t_token		*tmp;

	count = 0;
	tmp = start;
	while (tmp && tmp != end)
	{
		if (tmp->type == CMD || tmp->type == UNKNOWN)
		{
			expanded = expand_if_needed(tmp, mini);
			if (expanded && (expanded[0] != '\0' || tmp->quote_type != Q_NONE))
				count++;
			free(expanded);
		}
		tmp = tmp->next;
	}
	return (count);
}

char	*join_tokens_for_export(t_token **cur_tok_ptr, t_mini *mini)
{
	t_token	*tok;
	char	*arg;
	char	*tmp;
	char	*chunk;

	tok = *cur_tok_ptr;
	arg = ft_strdup("");
	if (!arg)
		return (NULL);
	while (tok && (tok->type == CMD || tok->type == UNKNOWN))
	{
		if (tok->quote_type == Q_S)
			chunk = ft_strdup(tok->str);
		else
			chunk = expand_if_needed(tok, mini);
		if (!chunk)
			break ;
		if (arg[0] != '\0' && !tok->glued)
		{
			free(chunk);
			break ;
		}
		tmp = ft_strjoin(arg, chunk);
		free(arg);
		free(chunk);
		arg = tmp;
		tok = tok->next;
		if (!tok || is_meta_token(tok->type))
			break ;
	}
	*cur_tok_ptr = tok;
	return (arg);
}



void	fill_export_args(char **args,
			t_token *start, t_token *end, t_mini *mini)
{
	int	i;

	i = 0;
	while (start && start != end)
	{
		if (start->type == CMD || start->type == UNKNOWN)
			args[i++] = join_tokens_for_export(&start, mini);
		else
			start = start->next;
	}
	args[i] = NULL;
}


/* for "'$USER'" */
char	*expand_if_needed(t_token *token, t_mini *mini)
{
	if (token->quote_type == Q_S)
		return (ft_strdup(token->str));
	if (token->quote_type == Q_D && token->is_dollar_quote)
		return (ft_strdup(token->str));
	return (expand_arg(token->str, mini, \
						token->quote_type, token->is_dollar_quote));
}

/*
find the value of the environment variable key in env
if not found, return an empty string
*/
char	*get_env_value(const char *key, char **env)
{
	int		i;
	size_t	key_len;

	i = 0;
	if (!env)
		return (ft_strdup(""));
	key_len = ft_strlen(key);
	while (env[i])
	{
		if (!ft_strncmp(env[i], key, key_len) && env[i][key_len] == '=')
			return (ft_strdup(env[i] + key_len + 1));
		i++;
	}
	return (ft_strdup(""));
}

/*
this function to find the value of the environment variable key in env.
if in the expand_arg function, we find a $, we move the index i to the next char
if after $ is not a valid variable name, we return "$"
if we can't find the variable name, we return an empty string.
*/
char	*expand_var(const char *str, int *i, t_mini *mini)
{
	int		start;
	char	*var;
	char	*val;

	if (!str[*i])
		return (ft_strdup(""));
	start = ++(*i);
	if (str[start] == '"' || str[start] == '\'')
	{
		(*i)++;
		return (ft_strdup(""));
	}
	if (str[start] == '?')
	{
		(*i)++;
		return (ft_itoa(mini->last_exit));
	}
	if (!str[start] || !(ft_isalpha(str[start]) || str[start] == '_'))
		return (ft_strdup("$"));
	while (str[*i] && (ft_isalnum(str[*i]) || str[*i] == '_'))
		(*i)++;
	var = ft_strndup(str + start, *i - start);
	val = get_env_value(var, mini->env);
	printf("[expand_var] variable name = '%s'\n", var);
	free(var);
	return (val);
}

/* for case special: start from "$""" */
char	*handle_special_case(const char *str)
{
	int		j;
	char	*after;

	j = 4;
	while (str[j] == '"')
		j++;
	after = ft_strdup(&str[j]);
	return (ft_strjoin_ff(ft_strdup("$"), after));
}

char	*expand_arg(const char *str, t_mini *mini, t_quote quote_type, bool is_dollar_quote)
{
	char	*result;
	int		i;
	int		old_i;

	result = ft_strdup("");
	i = 0;
	if (is_dollar_quote)
		return (ft_strdup(str));
	if (str[0] == '"' && str[1] == '$' && str[2] == '"' && str[3] == '"')
		return (handle_special_case(str));
	while (str[i])
	{
		old_i = i;
		if (str[i] == '\'' && quote_type == Q_NONE)
			result = ft_strjoin_ff(result, handle_single_quote(str, &i));
		else if (str[i] == '"')
			result = ft_strjoin_ff(result, handle_double_quote(str, &i, mini));
		else if (str[i] == '$')
			result = ft_strjoin_ff(result, expand_var(str, &i, mini));
		else
			result = ft_strjoin_ff(result, ft_strndup(str + i++, 1));
		if (i == old_i)
			i++;
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_arg_quote.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hho-troc <hho-troc@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 10:58:15 by hho-troc          #+#    #+#             */
/*   Updated: 2025/05/26 17:25:28 by hho-troc         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

char	*handle_double_quote(const char *str, int *i, t_mini *mini)
{
	char	*result;
	char	*chunk;

	result = ft_strdup("");
	(*i)++;
	while (str[*i])
	{
		if (str[*i] == '"')
			break ;
		if (str[*i] == '$')
			chunk = expand_var(str, i, mini);
		else
			chunk = ft_strndup(str + (*i)++, 1);

		result = ft_strjoin_ff(result, chunk);
	}
	if (str[*i] == '"')
		(*i)++;
	return (result);
}

char	*handle_single_quote(const char *str, int *i)
{
	int		start;
	char	*segment;

	start = ++(*i);
	while (str[*i] && str[*i] != '\'')
		(*i)++;
	segment = ft_strndup(str + start, *i - start);
	if (str[*i] == '\'')
		(*i)++;
	return (segment);
}



